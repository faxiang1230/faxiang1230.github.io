---
layout:     post
title:      "Art历史"
subtitle:   " \"简单的art历史\""
date:       2017-06-29 17:40:45
author:     "faxiang1230"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - andrioid
  - art
---
# ART的历史杂谈
因为接触ART的时间比较晚，很多都是听大神们讲，下面的野史姑且听之
## Dalvik的起源
我们都知道Android的应用大部分都是使用Java语言来开发的，不过2017年的Goole I/O上Goole推出了一门新的Kotlin语言，非常类似于Java的语言来作为Android应用开发的官方语言。
### 为啥选用Java呢?
Java语言在当时非常的火爆啊，就像今天的人工智能一样火爆,其本身也是一门高级语言，简单易用(吐槽一下C++)，文档详尽，论坛超多，随便一个问题基本都可以找到答案；总而言之就是Java开发者多，这样也就造就了现在的`生态圈,百万应用`;
### 为啥没用JVM呢?
Java本身是有JVM虚拟机的，也是非常完善的一套虚拟机，为啥没用现成的JVM呢?

|JVM|Dalvik|
|--|--|  
|基于栈|基于寄存器|  
|运行class|运行dex文件|  

**基于栈的方式:**  
都是存取栈指令，指令较短，但指令数较多

**基于寄存器方式:**  
需要指明源寄存器，目的寄存器，指令较长；

Dalvik因为要保证虚拟机在各个平台上都能运行,那么明显不是物理寄存器而是虚拟寄存器，需要和实际的寄存器映射，和直接寄存器相比还是差了一层;

Dalvik是有65535个虚拟寄存器的，而真实的机器上就未必有那么多了，所以Dalvik的指令集需要翻译到真实的机器指令上，必然还要经过一层转换.

Dalvik刚开始也是没有使用JIT技术，不过从2.2开始之后使用了JIT技术；并且还有一个快速翻译技术，不知道是个什么东东.我看2017 Google I/O上ART团队的人在讲优化编译的时候我头都大了，没学过编译原理的伤不起啊.

**class文件:**
每个类都会被编译成一个class文件，然后多个class文件可以被打包成jar，然后
被JVM装载    
**dex文件：**
将多个class文件中的字符串合并，这样就能减少好多字符串占用的存储空间，相当
于变相的压缩。size减小之后更加适合与当时存储较小的手机设备

class文件->dex文件转换:  
`dx --dex --output=hello.dex hello.class`

dalvik虚拟机海经过优化更加适合于移动设备:
```
精心设计的Zygote进程，能够最大化在多个进程中共享资源
常量池已被修改为只使用32位的索引，以简化解释器
```
### 为啥费这么大劲还要开发一门新语言呢?
Java出现了20多年的时间了，火了也有快20年了，很不幸在Java 1.6（在2006年12月发布，如今被称为Java 6发布之后，由于Sun Microsystem公司陷入了长期的经济问题，最终在2010年被Oracle收购.都知道Oracle善于玩这个:收购竞争对手，打入冷宫，Java，mysql，Solaris；然后Oracle就向google开炮了:在10年正式诉讼Google侵犯了Java专利权，两家打官司好多年，最终Google烦了，宣布Kotlin并放在第三方开源平台上进行继续开发.

这也是Android逐渐收回代码所有权的一个原因，逐渐将Android中开源的工具，库自己重新实现一遍来实现完全自主，想开源就开源，想闭源就闭源,实现商业的自主掌控权;
### Dalvik技术
都成历史了,暂时没精力研究了
#### JIT
都成历史了,暂时没精力研究了
## ART历史
为什么ART呢  
1.Dalvik虚拟机的技术产生的年代还是单核时代，所以很多的技术必然都是针对当时年代优化
的,就像我们很不理解x86里面的实模式一样.  
手机从单核到多核是一个必然趋势了，而且速度越来越快，存储越来越大，Dalvik已经不能胜
任运行时的任务了，所以干脆推到重来一遍.不过好的精华还是一直在用，Dalvik的JIT又重新
回到了ART中.

||Dalvik时代机器|ART时代机器|
|--|--|--|
|CPU|MSM7201A 双核架构 528MHZ|MSM8998 2.35GHz大四核+1.9GHz小四核|
|RAM|128M|4G|
|电池|1150mAh|3500mAh|
|存储|256M+扩展16G|ROM:64G+扩展128G|

### ART的新技术
#### AOT
在应用安装的时候就将应用中的dex全部能翻译的指令翻译成本地指令存储
在`/data/dalvik-cache/xx/`下，本地指令毕竟比interpretater要快，所以这种做法
极大的提升了应用启动速度，应用运行速度

**缺点:**  
需要额外的空间来存储本地指令，还相当大  
每次OTA的时候需要重新生成本地指令，需要时间长

不过相对于两个优点来说，那点缺点不是啥大问题，毕竟手机动不动都是32G，64G，128G了
#### GC
#### JIT和profile
在Android-N上这个东东又从Dalvik上拿回来了，主要的原因是google想要升级频繁点，OTA之后老是弹出那么个框框闹心不是。google真是贴心，为了讨好用户是不择手段，就是哭了程序员了，两三个月升级一次也不是问题，咱也可以忍忍，别整这么多事了，行不？

**主要的思路:**

在第一次程序运行时，不再使用OAT方式了，这样就节省了翻译的时间，特别是OTA之后那个框框;那么就选用JIT边翻译边运行，然后还有个记录官，记录到哪些方法运行多次之后，标记一下这个方法为hot，然后写入到profile文件中；

还有一个专门的翻译线程，专门等待系统idle或者充电的时候醒过来，然后翻翻profile文件，然后把指令翻译称本地指令然后存储在`/data/dalvik-cache`中；

优点:只有经常执行的方法才会翻译，这样的按需翻译真实贴心啊，既不浪费空间又能把活干了.

缺点:JIT毕竟是边翻译边运行，还是比OAT方式要稍慢一些

google I/O上人家就很聪明，和Dalvik虚拟机的性能比较啊，再差总也比dalvik好吧.
