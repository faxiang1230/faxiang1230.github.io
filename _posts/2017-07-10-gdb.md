---
layout:     post
title:      "gdb调试"
date:       2017-07-10 22:40:45
author:     "faxiang1230"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - gdb
  - linux
---
# gdb调试

## gdb通用准备
gdb是基于符号调试的工具，所以首先是需要符号的；编译时`-g`;而另外一些时候有些项目运行不带符号的程序，而将带有符号信息的可执行文件放在另外一个位置，那么需要手动加载符号文件位置:`file 符号表文件`；
可执行程序一般都是动态链接的，执行到动态库的时候也是需要手动加载动态库的符号文件:`set solib-search-path 动态库目录`
## tui模式
gdb参数`tui`或者进入之后`Ctrl+X+A`;再次重复命令`Ctrl+X+A`就会离开tui模式
## 传参
进入gdb之后`run 参数`
## 单步调试
`next`和`step`都是单步调试动作，不过`step`会进入函数里面，而`next`会跳到下一行而不会调入函数里面
恢复执行操作`continue`
上面三个都可以加上n:
`next n`,继续下面n行
`step n`继续stepping into模式n行,
`continue n`继续下去，忽略n个断点
finish:恢复执行直到当前函数返回为止
until:恢复执行直到当前循环体外的下一行程序，就是结束当前for，while循环；实际上until也可以接受break一样的参数:`until 16`在当前活动源文件侠16行停止
## 断点
断点添加的基本命令:`break`,可以针对文件行数，函数名来进行断点
`break test.c:16`
`break main`
`break 16`当前活动源代码文件中的行号
条件断点:有时候发生了偶然出现的bug，不想每次都断住然后continue来，可以使用条件断点
`break bug() if （condition）`
condition可以有一下几种形式:
相等，逻辑，不等运算符
`==,<,>,>=,<=,||,&&,!=`
换位，移位运算符
`|,&,<<,>>`
算术运算符
`+,-,*,/,%`
自己的函数，只要gdb能够找到
`break test.c:16 if (parse())`
标准库里的函数
`break test.c:main if(size(argv))`

C++中的断点，除了可以使用文件行之外在指定函数处断点
`命名空间::类::方法`
查看断点:`info b`
删除断点:
`delete breakpoint n`
禁用断点`disable n`
启用断点`enable n`
在特定线程中中断

你可以定义你的断点是否在所有的线程上，或是在某个特定的线程。GDB很容易帮你完成这一工作。
```
    break <linespec> thread <threadno>
    break <linespec> thread <threadno> if ...
```
linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，你可以通过"info threads"命令来查看正在运行程序中的线程信息。如果你不指定thread <threadno>则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。如：
```
     (gdb) break frik.c:13 thread 28 if bartab > lim
```
当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。
另一种形式是`condition n if (local=0)`,指定断点n的停止条件:变量local的值为0

## 断点命令列表
```
commands n
>......
>continue
>end
```
## 恢复执行

## 检查变量
最简单的打印出某个局部变量或全局变量的值`print local`
变量不存在问题:仔细检查变量是否存在，特别是生存时间是否正确；然后检查一下优化级别，有可能在高优化级别中被优化掉了
## 线程操作
查看当前线程`info threads`
切换当前调试的线程为指定ID的线程:`thread ID`
在所有线程中相应的行上设置断点:`break thread_test.c:123 thread all`
让一个或者多个线程执行GDB命令command:`thread apply ID1 ID2 command`
让所有被调试线程执行GDB命令command:`thread apply all command `

`set scheduler-locking off|on|step` 估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on 只有当前被调试程序会执行。 step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。


## 监视点
在变量读、写或变化时中断，这类方式常用来定位bug。
```
    watch <expr>    变量发生变化时中断
    rwatch <expr>    变量被读时中断
    awatch <expr>     变量值被读或被写时中断
```
可以通过info watchpoints [n]命令查看当前观察点信息
## 遍历栈帧
最简单的命令`backtrace`就可以打印出当前栈帧的回溯
也可以通过`frame`来指定某个帧，当前帧为0，父帧为1，祖父帧为2，类推，通过`frame n`回到某个帧上；但是不改变当前的执行点；
