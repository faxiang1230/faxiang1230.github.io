---                                                                                                                                                                                                                
layout:     post
title:      "Linux进程管理"
date:       2017-12-27 23:00:00
author:     "faxiang1230"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - kernel
  - process
---
# 进程管理
进程管理主要的工作就是管理多个进程如何瓜分CPU时间，而进程有两个很重要的特征:优先级和状态  
不同的进程要求不同，所有进程完全一视同仁就是最大的不公平，所以抽象出了优先级的概念，它决定了获得`CPU运行时间`和`响应延迟`  
进程也是需要依赖其他资源的，它如何走过自己的一生内核也划分了不同的状态。当然，里面最重要的几种状态反应它的
能力:`RUNNING`,`INTERRUPTIBLE`,`UNINTERRUPTIBLE`  

进程是什么，如何抽象管理的?  
进程就是程序运行时的实体，只有运行时它才会占用很多的资源，否则只是占据一点存储空间。运行时的进程会根据自身代码不同占用不同的资源，完成不同的任务，但是有一些核心的资源是进程必须的:进程管理数据`task_struct`、打开的文件、文件系统信息、内存信息、cpu信息。  
进程之间是存在很多关系的:父子,兄弟,线程组等，这些都是有专门的链表来管理:slibing,children;其中特殊的一个是所有的进程都会挂在init_task的tasks链表头中  
内存是用来保存数据的，在进程运行期间负责所有数据的保存，有代码数据，堆，栈数据等  
cpu信息是代表进程参与任务调度的数据:sched_entity

进程创建，销毁  
创建:主要就是根据do_fork时传入的标志复制或者新建进程管理信息.   
fork():就是copy父进程的task_struct,内存管理信息，文件信息，文件系统信息，信号等  
![](/images/fork.jpg)   
当父子进程有任何一方修改这些资源的时候都会分裂，创建独属于自己的资源  
vfork():CLONE_VM,CLONE_VFORK  
![](/images/vfork.jpg)  
pthread_create:CLONE_VM,CLONE_FS,CLONE_FILES,CLONE_SIGHAND,CLONE_THREAD  
![](/images/pthread.jpg)  

COW:在分配资源方面系统尽可能懒惰，能延迟分配的延迟,能不分配的就不分配，能少分配的就少分配，一句话:懒也是门技术  

如何瓜分CPU时间:实时调度类，普通调度类  
进程如何选择调度类，实时调度类怎么瓜分进程
明白进程管理对于那些人有用?

## 进程生命周期
![](/images/process_state.jpg)

可中断睡眠和不可中断睡眠的区别:能不能被信号唤醒，都是从RUNNING状态下迁移出来，不再被调度。
一般都是设置好可以唤醒的条件，然后设置自身的状态，调用schedule(),主动让出CPU.
而不可中断的睡眠不能被信号唤醒，用户空间就完全没有办法了，只有内核能够唤醒。

僵尸进程:
当进程死去的时候，只是将所占据的资源释放掉了，但是还没有从全局进程表中移除。
父进程需要在子进程终止的时候,需要调用wait4，向内核证实父进程已经确认子进程死亡了。
父进程没有确认子进程死亡的时候，子进程就是僵尸进程了。

## 进程描述符
进程包含的信息分类:  
1.可执行文件  
2.内存mm_struct  
3.cpu相关的:优先级，调度器相关的调度体，时间，统计信息等  
4.打开的文件，万物皆文件，设备也是文件  
5.信号，共享内存等进程间通信  
6.进程的凭据:uid,gid,ppid,pid等  
7.进程的状态:RUNNING,INT,UNINT,DEAD,ZOMBIE  
8.进程之间的关系:全局的进程表，亲缘进程关系  
9.资源限制  
## 进程创建和销毁，唤醒
进程的创建无非就是创建管理数据，就是task_struct，并且在各种资源中完成角色建立，　　
使用COW的原因:进程通常只使用内存页的一部分，不经常访问父进程的全部内存页。全部复制遇到execv之后负面效应会更严重。
COW只复制页表,fork之后父子进程的地址空间指向同样的物理内存页，且对两者的页表都标记了只读属性，所以谁先写就会发生page fault.用户栈也是使用时再分配，呵呵了
## 孤儿进程的托孤
## 调度器
调度策略和调度类映射:NORMAL,BATCH,IDLE对应CFS;RR,FIFO对应于rt.
### 时间片分配
时间片只在rq上分配，没有`RUNNING`的进程是没有资格瓜分时间片的。时间片的瓜分仍然是按照进程的优先级来决定的，优先级高的获得更多的CPU运行时间。  
用户空间可以使用nice命令来查看优先级，也可以通过系统调用来改变优先级，在用户空间中他理解的优先级为`-20~+19`，值越低，优先级越高  
内核使用0-139来标示内部优先级，而0-99给实时进程使用的，100-139给普通进程使用的。　　
而内核中有三个优先级来表示进程真正的重要程度:  
静态优先级:就是nice值看到的，用户可以修改  
普通优先级:这个主要是作为非实时和实时进程优先级计算的统一接口，实时进程根据调度策略来分别的;动态提升进程的优先级时(使用了RT-Mutex),根据prio值来检测是不是临时提升到了实时进程级别.  
动态优先级:这个就是最后的优先级，对于实时进程就是按照优先级依次执行;对于普通进程，根据这个优先级来计算权重，然后瓜分CPU时间。  
优先级继承:进程fork时，子进程继承父进程的静态优先级，动态优先级并不会提升，确保实时互斥量引起的优先级提高不会传入到子进程.  
### 调度策略
完全公平调度器:
系统对待所有进程都是完全公平的，当然这个公平是假的，只是看起来公平。目的就是消除不公平，挑选等待时间最长的进程来运行。这样消除不公平之后，大家看起来是一样。  
虚拟时钟,流速慢于实际的时钟，依赖于当前等待调度器挑选的进程的数目  

调度器处理进程的状态:  
1.刚fork后，就会调用wake_up_new_task唤醒新进程，将调度体加入到就绪队列中  
2.从就绪队列中删除:  
到可中断，不可中断状态:主动睡眠并且调用schedule()来让给其他CPU,从就绪队列中移除  
3.从睡眠状态回到就绪队列  
睡眠的时候将自己挂在workqueue上，等待有人来唤醒自己，然后在唤醒的时候就会重新有机会添加到  

prio_to_weight数组是根据根据nice值定义的，一般的概念是进程每降低一个nice值，则多获得10%的CPU时间，每升高一个nice值，则放弃10%的CPU时间。为执行该策略，内核通过这个数组将优先级转换为权重值。而prio_to_w,ult数组和prio_to_weight数组中相同索引的值的关系是`prio_to_wult[i]=2^32 / prio_to_weight[i]`，之所以引入这个数组是避免在计算虚拟运行时间时执行除法。内核中使用`delta_exec * (NICE_0_LOAD / weight)`的公式来将实际时钟时间（delta_exec）转换为虚拟运行时间，通过prio_to_wmult就可以将这个公式转换为`(delta_exec * NICE_0_LOAD) * inv_weight >> 32`，将除法很巧妙地转换为乘法和移位操作。

理想时间片的计算:  
1.确定物理时间周期:当前有n个进程，如果小于阈值(sched_latency/sched_min_granularity)，物理时间周期为sched_latency;如果进程非常多的话，为了防止进程的频繁切换，设置了一个最小的运行时间:sched_min_granularity,此时一个物理时间周期为:`n x sched_min_granularity`;  
2.计算自己的理想运行周期:`s = p*P[w/rw]`：`物理时间 * 自身权重 / 总权重`  
3.计算虚拟理想运行周期:`物理周期 * NICE_0_LOAD / 自己权重`  

ENQUEUE和DEQUEUE对rq的影响:  
每次有新的进程加入到rq上时，重新计算整个rq的weight,加入到rq中，然后重新计算所有的时间片。特别是如果新进程优先级比当前进程优先级更高，那么就会发生抢占，设置抢占标志。  
进程从rq中移除时，问题相对没有那么大。  
## 抢占
进程切换分为两种:自愿切换和强制切换。  
自愿切换的标准就是:从rq中移除，然后进入INT,UNINT状态，等待IO，资源等情况。  
强制切换是自身迫不得已被踢出CPU,自身仍然在rq上,等待机会重新占用CPU。  
自愿切换就是进入INT/UNINI状态，UNINTERRUPTIBLE状态只能是在内核中主动进入。INTERRUPTIBLE可以接收信号，用户空间时可以通过signal来发送信号来唤醒INTERRUPTIBLE的进程的  

信号完全就是软件的概念,不是硬件上的概念，可以看成软件中断，你可以自己注册信号处理，也可以使用系统默认的信号处理方法，当然有些信号用户空间没有权限处理。  
强制切换就是自身被强制切下来了，一个是自身时间片用完了，这个就是发生在周期性的tick中断中，检查自身时间片是否大于理想运行时间。另外一种是有更高优先级的进程出现了，需要优先运行高优先级进程，再细分为几种:进程唤醒，进程创建唤醒，进程优先级动态提升。  

切换过程:设置当前进程TIF_NEED_RESCHED标志，执行进程切换，中间的过程不是原子性的，所以分开来说。  
何时会设置TIF_NEED_RESCHED:就是切换的时候设置:自愿切换和强制切换。  
执行切换:检查TIF_NEED_RESCHED标志，如果设置的话就执行抢占。  
用户抢占和内核抢占,其实感觉用户空间抢占说法比较奇怪，用户的代码肯定没有权限来抢占其他进程，所有的还是系统代码来做，不知道为什么叫用户空间抢占。两种情况:系统调用返回和中断返回用户空间(用户空间进入内核空间只有这两种途径)  
内核抢占:内核有些位置是禁止抢占的，从禁止抢占的位置离开的时候就会检查TIF_NEED_RESCHED标志。
### schedule
## 负载均衡
### 负载均衡时机
在每次tick的时候触发负载均衡，然后就开始检查是否需要负载均衡  
idle时检查是否进行负载均衡  
### 负载计算
### 负载均衡策略
### 调度域，调度组
### 亲缘性绑定
