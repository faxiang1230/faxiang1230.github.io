有些内核函数或者内核变量是不导出的，但是确实需要用，那该怎么办？因此寻找内核符号地址就有必要进行一下总结，更有甚，如果想找一条特定的指令，比如movl的指令地址，那更需要投入一些精力！总的来说，我总结了下面五种方式：
1.通过procfs中的kallsym文件或者System.map文件直接查找
这种方式借助于文件，依赖于文件的存在，不需要什么编程能力，只要会在文件中查找信息即可
2.google一下
这种方式借助于互联网，依赖你对信息的筛选能力。最有代表性的，寻找system_call和sys_call_table的地址，网上会说先找到0x80个中断描述符，然后在寻找机器码特征。这种方式实际上广泛用于替换系统调用这种小伎俩。
3.使用dump_stack
这种方式需要在你想得到的地址调用链条的下游调用dump_stack，然后通过dmesg信息得到相应的地址信息。同理等价的方式就是故意制造错误，迫使内核打印地址。
4.利用栈结构和栈原理寻找
记住栈中会有什么信息，一般会有参数地址信息，会有一个个的栈帧信息，每当调用call指令的时候，还会将下一条指令的地址压入栈中。通过这些信息我们可以得到大量的地址信息。
5.从/dev/mem中搜索
这个方式最有技术含量，也最困难，然而什么外界工具都不需要，甚至都不需要你懂编程语言。然而需要你对机器码指令十分精通，对内存布局十分精通，它实际上是一种机器语言的编码方式
     从上述方法可以看出，从1到5，对外部工具的依赖越来越少，然而对自身的知识储备要求越来越高，因此完成一件事的成本貌似是守恒的。如果一个人的知识储备非常丰富，本身有十分聪明，他会使用哪种方式呢？会使用第五种方式吗？我想绝对不！他肯定尝试使用第一种方式，然后第二种...他很有可能永远不会使用第五种方式，虽然他有能力完成！这就是说，在解决问题的时候，我们不会在乎难度和能力，我们只在乎成本，因此我们总是喜欢从阻力最小的方向上切入，有简单的方式就不使用更复杂的方式，这也印证了简单就是美的普世原则。在力求简单的过程中，我们不得不积累更多的知识，进行更多的尝试...
     想起一句广告词，加速，是为了放慢脚步！
