# 信号
## 用途

信号是软件中断，提供了一种异步机制来控制程序:通过`Ctrl+c`来产生`SIGINT`投递到程序，默认会停止程序。
信号本身是不可靠的，不能保证到达时间和是否能到达，例如程序处于不可中断睡眠状态，这时候是不会被信号唤醒。

信号的处理:
忽略:
捕捉:使用`sigaction`改变信号的默认动作，处理动作可以为`SIG_IGN/SIG_DFL`
默认动作:

信号的阻塞处理:当正在信号处理时来了新的信号怎么办，信号处理是不可嵌套的

中断的系统调用:
## 信号的设计哲学

## 详细
```
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
```

fork和exec对于信号的影响:
fork父子进程共享进程的代码段，所以子进程可以继承父进程的信号处理函数。而exec时会重新载入整个镜像，所以原来的信号处理函数对新的进程是不可见的，所以会将信号重置成默认状态。  

每个线程拥有一个task_struct,
进程中的线程共享信号处理sighand_struct,
信号屏蔽关键字，每个线程都有自己的线程信号屏蔽集,可以通过`pthread_mask`来屏蔽对信号的处理，仅
留下需要处理该信号的线程来处理指定的信号。  
可以通过`pthread_kill`来发送信号给指定的线程。如果使用`kill`会发送到指定的进程，结果是：正在
运行的线程会处理该信号，如果该线程没有注册信号处理函数，那么会导致整个进程退出。  

信号屏蔽集:
信号阻塞:信号处理时是否
信号重发:
同一进程线程间共享信号处理函数

各线程有独立的信号屏蔽
默认进程间继承信号屏蔽
## 通信
### 进程间通信
### 多线程信号处理
### 关机处理SIGTERM
