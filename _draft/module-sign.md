# Linux kernel模块内核签名
可信计算的环境是需要形成一个信任链的，中间基本上是通过密码学的原理以签名来作为信任链的，最开始的信任基础是始于硬件的，通过厂家在只读的ROM中内置证书，通常在PC中是BIOS,而第二步现在是一些EFI引导程序，

内核的配置:
CONFIG_MODULE_SIG:内核需要签名
MODULE_SIG_FORCE:强制要求module签名同内置签名一致
CONFIG_SYSTEM_TRUSTED_KEYRING：签名文件
MODULE_SIG_ALL:编译完成后对所有的内核模块进行签名

启动参数控制:
sig_enforce

# pem是什么?怎么生成的?PCKS#7签名机制?
# 实践
前提:有公匙和私匙
公匙:signing_key.x509
私匙:signing_key.priv // 新版版本kernel为signing_key.pem详见更新部分

使用内核自带工具
$ perl <kernel_path>/scripts/sign-file sha512 signing_key.priv signing_key.x509 <module>.ko
kernel_path填写内核根目录路径

module处填写模块名字

该命令会生成module.ko文件（若在当前路径下会将之前的文件覆盖）

验证签名是否成功
使用命令验证

$ hexdump -C <module>.ko | tail
```
00058700  5b 39 06 5f 39 ce 05 96  24 e8 6e 00 50 d3 73 b0  |[9._9...$.n.P.s.|
00058710  ff 11 0a 24 a6 69 98 22  e5 c2 e9 5c 45 54 f7 fc  |...$.i."...\ET..|
00058720  0b 68 7b 54 ee ee 8e 0e  5d e5 af 56 d7 07 e9 08  |.h{T....]..V....|
00058730  10 8e ce f1 9c 67 1d 09  6f 3c c4 f3 2c 0a a9 44  |.....g..o<..,..D|
00058740  0e 5b ab ec 6b 74 38 27  da 9c 9c 16 58 25 65 be  |.[..kt8'....X%e.|
00058750  11 c4 f6 d5 e1 ec 4d e8  e2 fe b2 57 4b 01 06 01  |......M....WK...|
00058760  07 14 00 00 00 00 00 01  02 7e 4d 6f 64 75 6c 65  |.........~Module|
00058770  20 73 69 67 6e 61 74 75  72 65 20 61 70 70 65 6e  | signature appen|
00058780  64 65 64 7e 0a                                    |ded~.|
00058785
```

linux kernel 4.3.3及更高的版本使用如下命令签名
@$(KDIR)/scripts/sign-file sha512 $(PWD)/signing_key.pem $(PWD)/signing_key.x509 module.ko dest_module.ko
新版本中原本perl脚本sign-file被改为可执行程序。

# 相关密码学概念
keystore:
Keytool是一个Java数据证书的管理工具 ,Keytool将密钥（key）和证书（certificates）存在一个称为keystore的文件中。
在keystore里，包含两种数据：
```
1. 密钥实体（Key entity）——密钥（secret key）又或者是私钥和配对公钥（采用非对称加密）
2. 可信任的证书实体（trusted certificate entries）——只包含公钥
```
ailas(别名)每个keystore都关联这一个独一无二的alias，这个alias通常不区分大小写
X509
公钥/私钥/签名/验证签名/加密/解密/非对称加密

　　我们一般的加密是用一个密码加密文件,然后解密也用同样的密码.这很好理解,这个是对称加密.而有些加密时,加密用的一个密码,而解密用另外一组密码,这个叫非对称加密,意思就是加密解密的密码不一样.初次接触的人恐怕无论如何都理解不了.其实这是数学上的一个素数积求因子的原理的应用,如果你一定要搞懂,百度有大把大把的资料可以看,其结果就是用这一组密钥中的一个来加密数据,可以用另一个解开.是的没错,公钥和私钥都可以用来加密数据,相反用另一个解开,公钥加密数据,然后私钥解密的情况被称为加密解密,私钥加密数据,公钥解密一般被称为签名和验证签名.

　　因为公钥加密的数据只有它相对应的私钥可以解开,所以你可以把公钥给人和人,让他加密他想要传送给你的数据,这个数据只有到了有私钥的你这里,才可以解开成有用的数据,其他人就是得到了,也看懂内容.同理,如果你用你的私钥对数据进行签名,那这个数据就只有配对的公钥可以解开,有这个私钥的只有你,所以如果配对的公钥解开了数据,就说明这数据是你发的,相反,则不是.这个被称为签名.

　　实际应用中,一般都是和对方交换公钥,然后你要发给对方的数据,用他的公钥加密,他得到后用他的私钥解密,他要发给你的数据,用你的公钥加密,你得到后用你的私钥解密,这样最大程度保证了安全性.

　　RSA/DSA/SHA/MD5

　　非对称加密的算法有很多,比较著名的有RSA/DSA ,不同的是RSA可以用于加/解密,也可以用于签名验签,DSA则只能用于签名.至于SHA则是一种和md5相同的算法,它不是用于加密解密或者签名的,它被称为摘要算法.就是通过一种算法,依据数据内容生成一种固定长度的摘要,这串摘要值与原数据存在对应关系,就是原数据会生成这个摘要,但是,这个摘要是不能还原成原数据的,嗯....,正常情况下是这样的,这个算法起的作用就是,如果你把原数据修改一点点,那么生成的摘要都会不同,传输过程中把原数据给你再给你一个摘要,你把得到的原数据同样做一次摘要算法,与给你的摘要相比较就可以知道这个数据有没有在传输过程中被修改了.

　　实际应用过程中,因为需要加密的数据可能会很大,进行加密费时费力,所以一般都会把原数据先进行摘要,然后对这个摘要值进行加密,将原数据的明文和加密后的摘要值一起传给你.这样你解开加密后的摘要值,再和你得到的数据进行的摘要值对应一下就可以知道数据有没有被修改了,而且,因为私钥只有你有,只有你能解密摘要值,所以别人就算把原数据做了修改,然后生成一个假的摘要给你也是不行的,你这边用密钥也根本解不开.

　　　CA/PEM/DER/X509/PKCS

　　一般的公钥不会用明文传输给别人的,正常情况下都会生成一个文件,这个文件就是公钥文件,然后这个文件可以交给其他人用于加密,但是传输过程中如果有人恶意破坏,将你的公钥换成了他的公钥,然后得到公钥的一方加密数据,不是他就可以用他自己的密钥解密看到数据了吗,为了解决这个问题,需要一个公证方来做这个事,任何人都可以找它来确认公钥是谁发的.这就是CA,CA确认公钥的原理也很简单,它将它自己的公钥发布给所有人,然后一个想要发布自己公钥的人可以将自己的公钥和一些身份信息发给CA,CA用自己的密钥进行加密,这里也可以称为签名.然后这个包含了你的公钥和你的信息的文件就可以称为证书文件了.这样一来所有得到一些公钥文件的人,通过CA的公钥解密了文件,如果正常解密那么机密后里面的信息一定是真的,因为加密方只可能是CA,其他人没它的密钥啊.这样你解开公钥文件,看看里面的信息就知道这个是不是那个你需要用来加密的公钥了.

　　实际应用中,一般人都不会找CA去签名,因为那是收钱的,所以可以自己做一个自签名的证书文件,就是自己生成一对密钥,然后再用自己生成的另外一对密钥对这对密钥进行签名,这个只用于真正需要签名证书的人,普通的加密解密数据,直接用公钥和私钥来做就可以了.

　　密钥文件的格式用OpenSSL生成的就只有PEM和DER两种格式,PEM的是将密钥用base64编码表示出来的,直接打开你能看到一串的英文字母,DER格式是二进制的密钥文件,直接打开,你可以看到........你什么也看不懂!.X509是通用的证书文件格式定义.pkcs的一系列标准是指定的存放密钥的文件标准,你只要知道PEM DER X509 PKCS这几种格式是可以互相转化的.
