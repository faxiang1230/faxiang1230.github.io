---
layout:     post
title:      "linux kprobe"
date:       2019-08-07 16:50:45
author:     "faxiang1230"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - linux
  - trace
---
# linux kprobes
kprobes出现了非常长的时间,最早是2.6.9版本中，最早能够追溯到2004年，距离现在15年，一直没有为人所知，但却是隐藏在诸多技术后的一个基础组件，例如ftrace,最近非常火热的ebpf.
kprobe是什么?它是kernel probes(我翻译成探针)，是一种debug机制，它是由IBM开发的,最初计划用来和另外一个工具DProbes配套使用的，只是只有kprobe被合并到mainline了。但是kprobes使用起来有些复杂，还需要单独编写module,所以kprobe为了存活只能不停的寻找和他能够配合的，后来和ftrace勾搭上了，现在还和ebpf眉来眼去。

kprobes通常被用来查找性能瓶颈，记录指定的事件，用来trace,它理论上能够监视任何的事件，但是有一点:它实现不了gdb的watch功能。目前它主要作为ftrace,ebpf,SystemTap等框架和工具的后端存在，主要用来做日志了，看起来它也混的挺憋屈的，有强大的功能就是没人用。它主要有三类:kprobe,kretprobe,jprobe,对外称为kprobes,最后好多人都弄混了kprobes/kprobe。不过哥三各有用途，kprobe作为最常用的，可能就是记录日志,而jprobe类似于kprobe的pre_handler,但是有个优点，不需要从寄存器中提取各种参数，直接就定义它的类型和原始函数的参数一致就可以直接使用了，而kretprobe可以查看这个函数执行结束后参数的变化，和kprobe一个在函数开始，一个在函数结束。而最新的内核中jprobe因为它的优势不明显已经被干掉了，由此可见哪里都有竞争，就是代码也得证明它能干别人干不了的事情并且干得很好，没有代码是永生的，历史的车轮过后就是无人问津的垃圾代码，就算你合并到mainline中也不是高枕无忧。

kprobe可以插入到任何指令位置(除了黑名单函数之外)，jprobe只能放到函数开始处,kretprobe只会在函数结束的时候才会执行。

|      |插入位置| 用途 |
|------|-------|-----|
|kprobe|函数的任何位置(除了黑名单函数之外)|记录日志|
|jprobe|放到函数开始|查看传入参数|
|kretprobe|函数结束|查看返回参数|

## 原理
### kprobe
可以设置pre_handler和post_handler
## reference

1.[An introduction to KProbes](https://lwn.net/Articles/132196/)  
2.Documentation/kprobes.txt  
3.[Kernel- and User- Probes in Linux: Magic?](https://dev.framing.life/tracing/kernel-and-user-probes-magic/)
