# RCU(Read-Copy Update)
RCU是一种同步机制，常用的同步机制有spinlock,mutex等，这些同步机制是通过原子操作+算法来实现的。原子操作
## 原理
通过维护对象的多个版本来供不同时间点开始访问对象的进程使用,
如果不考虑内存的垃圾占有率，可以参考gc方法，每隔10s来回收一次不再使用的版本对象；
允许多个读并发发生
单独的写操作

1.从访问对象O的角度来看，进程有两个区域:访问O区域和未访问O区域，当进程经过一次`未访问O区域`时，

RCU实现是基于这样一种想法:在时间点T原子更新数据(数据类型根据arch的指令有一定要求，例如支持short，short int,int,在64bit系统中支持long型数据，通常使用的是指针，即long型),在T之前访问的数据都指向旧的数据，而T之后访问的数据都指向新的数据，要实现这样的效果除了原子操作之外还需要进行memory barrier处理，在现代CPU中加入了乱序执行功能，实际执行的过程和我们期望的顺序可能不一样，需要在更新数据后来隔离T前后的指令流分离。之后
## 实现
## 用途
### 内核RCU
### 用户空间RCU-urcu
urcu是内核RCU在用户空间的一种实现版本，基本的思路是完全相同的，以原子操作为核心(这个需要编译器特性支持),用户空间静默期的选择。
有几种版本:
quisent-sate:
具备最好的读性能，但是需要每个读线程周期性的声明其在静默期，这就给程序设计施加了一些约束。
signal:需要使用`SIGUSR/SIGUSR2`,用户需要放弃使用其中一个信号
generic：不要求修改程序，而且可以在库中使用，但是会有较大的读消耗。  


## Reference
[urcu]()
[rcu]()
