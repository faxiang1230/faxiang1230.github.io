---
layout:     post
title:      "工程实践经验1"
date:       2019-04-09 20:40:45
author:     "faxiang1230"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - 软件工程
---
# 工程实践-总结1
## 内存泄露
内存泄露是通过malloc/calloc/realloc申请的，他们属于匿名页内存(没有后备存储)，就靠指针来使用
这段内存，如果没有指针指向这段内存，那么就永远也用不了，直到进程的终结才会被系统回收。

1.尽量不要跨越方法使用内存对象,如果能够在一个方法内完成内存对象的申请和释放是最完美的
理想太美好，现实告诉你不好
2.跨越方法的内存对象的申请、使用、释放，尽量将申请和释放封装,成对使用
3.警惕那些在方法中申请的内存对象,返回给调用者内存对象的
经典的getline()中lineptr指向一段新申请的内存，如果没有释放就每调用一次就泄露一块内存。

随着系统业务的复杂性，代码量越多，bug越多，内存泄露的几率越大。需要系统的工具来检测内存泄露问题
1.封装malloc,free,加入调试信息
2.使用gcc的工具:valgrind,address sanitizer

## 代码的健壮性
代码的健壮性是对于异常情况的处理情况，仍然能够正常地运行下去。
1.对于每一次系统调用都检查返回结果,不要因为99%的正确性忽略了它可能的异常。
记得对于资源的清理和对于异常现场信息的错误提示和保存。

## 面向对象
特别是习惯使用C语言等面向过程的语言通常是缺乏面向对象的思维的。习惯的思考方式是这件事可以分解为
步骤1,2,3,4,5,然后我写５个方法分别完成这5件事就完成了本次业务。
没有错误,但是有问题,可扩展性太差。
推荐阅读:[C语言的面向对象](https://blog.csdn.net/jus3ve/article/details/78516966)


## 可维护性和性能的权衡
软件设计中太多的权衡了，大多数是性能和其他(响应速度，power，可维护性)PK了。
这个题目真正想表达的是性能和bug的权衡，不可维护就是说现在可能没有bug,但是其他人很难修改这块代码，
这块代码成了个人专属

## 开源对个人的意义
1.开源使自己代码没有隐藏的，如果有人看到了你的代码并进行指摘，你又前进了一步。开源社区是进步非常快的地方，有很多热心的牛人对你进行指导，帮你纠正错误，是你能快速达到某一水平
2.开源能够证明自己，自己的代码对别人有用对于一个工程师来说是在没有更加激动的消息了
3.开源能够提升自己在行业内的影响力
